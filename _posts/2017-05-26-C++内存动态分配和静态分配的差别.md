---
layout: post
title: C++内存动态分配和静态分配的差别
tags: [C++]
---

## C++内存动态分配和静态分配的差别

内存的静态分配和动态分配的区别主要是**两个**：

​      一是**时间不同**。静态分配发生在程序编译和连接的时候。动态分配则发生在程序调入和执行的时候。

​      二是**空间不同**。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由函数malloc（new）进行分配。**不过栈的动态分配和堆不同，他的动态分配是由编译器进行释放，无需我们手工实现**。



所谓**动态内存分配**就是指在程序执行的过程中动态地分配或者回收存储空间的分配内存的方法。动态内存分配不象数组等静态内存分配方法那样需要预先分配存储空间，而是由系统根据程序的需要即时分配，且分配的大小就是程序要求的大小。
​    例如我们定义一个float型数组：

​        float score[100]; 　　

​    但是，在使用数组的时候，总有一个问题困扰着我们：数组应该有多大？在很多的情况下，你并不能确定要使用多大的数组，比如上例，你可能并不知道我们要定义的这个数组到底有多大，那么你就要把数组定义得足够大。这样，你的程序在运行时就申请了固定大小的你认为足够大的内存空间。即使你知道你想利用的空间大小，但是如果因为某种特殊原因空间利用的大小有增加或者减少，你又必须重新去修改程序，扩大数组的存储范围。这种分配固定大小的内存分配方法称之为静态内存分配。但是这种内存分配的方法存在比较严重的缺陷，特别是处理某些问题时：在大多数情况下会浪费大量的内存空间，在少数情况下，当你定义的数组不够大时，可能引起下标越界错误，甚至导致严重后果。 
​    我们用动态内存分配就可以解决上面的问题. 所谓动态内存分配就是指在程序执行的过程中动态地分配或者回收存储空间的分配内存的方法。动态内存分配不象数组等静态内存分配方法那样需要预先分配存储空间，而是由系统根据程序的需要即时分配，且分配的大小就是程序要求的大小。从以上动、静态内存分配比较可以知道动态内存分配相对于静态内存分配的特点： 
　　 1、不需要预先分配存储空间；
　　 2、分配的空间可以根据程序的需要扩大或缩小。 
​    要实现根据程序的需要动态分配存储空间，就必须用到malloc函数.
​    malloc函数的原型为：void *malloc (unsigned int size) 其作用是在内存的动态存储区中分配一个长度为size的连续空间。其参数是一个无符号整形数，返回值是一个指向所分配的连续存储域的起始地址的指针。还有一点必须注意的是，当函数未能成功分配存储空间（如内存不足）就会返回一个NULL指针。**所以在调用该函数时应该检测返回值是否为NULL并执行相应的操作**。

​    静态内存是在程序一开始运行就会分配内存，直到程序结束了，内存才被释放。
​    动态内存是在程序调用在程序中定义的函数时才被分配，函数调用结束了，动态内存就释放。

由**malloc系统函数**分配的内存就是从**堆上分配**内存。从堆上分配的内存一定要自己释放。用**free释放**，不然就是术语——“**内存泄露**”—— Memory Leak。于是，系统的可分配内存会随malloc越来越少，直到系统崩溃。

**栈内存分配**

```c
char*
    AllocStrFromStack()
    {
        char pstr[100];
        return pstr;
    }
```

**堆内存分配**

```c
char* AllocStrFromHeap( int len )
{
    char *pstr;
 
    if ( len <= 0 )
        return(NULL);
    return( ( char * ) malloc( len ) );
}
```

对于第一个函数，那块pstr的内存在函数返回时就被系统释放了。于是所返回的char*什么也没有。而对于第二个函数，是从堆上分配内存，所以哪怕是程序退出时，也不释放，所以第二个函数的返回的内存没有问题，可以被使用。但一定要调用free释放，不然就是Memory Leak！

​    在堆上分配内存很容易造成内存泄漏，这是C/C++的最大的“克星”，如果你的程序要稳定，那么就不要出现Memory Leak。所以，在使用malloc系统函数（包括calloc，realloc）时千万要小心。

对于malloc和free的操作有以下规则：

  1) 配对使用，有一个malloc，就应该有一个free。（C++中对应为new和delete）

  2) 尽量在同一层上使用，不要像上面那种，malloc在函数中，而free在函数外。最好在同一调用层上     使用这两个函数。

  3) malloc分配的内存一定要初始化。free后的指针一定要设置为NULL